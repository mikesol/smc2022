% -----------------------------------------------
% Template for SMC 2022
% based on SMC 2022 template
% -----------------------------------------------

\documentclass{article}
\usepackage{smc}
\usepackage{enumitem}% http://ctan.org/pkg/enumitem
\usepackage{times}
\usepackage[htt]{hyphenat}
\usepackage{listings}
\usepackage{ifpdf}
\usepackage[english]{babel}
\usepackage{cite}

\lstdefinestyle{psstyle}{
  basicstyle=\ttfamily\small
}

%%%%%%%%%%%%%%%%%%%%%%%% Some useful packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%% See related documentation %%%%%%%%%%%%%%%%%%%%%%%%%%
%\usepackage{amsmath} % popular packages from Am. Math. Soc. Please use the
%\usepackage{amssymb} % related math environments (split, subequation, cases,
%\usepackage{amsfonts}% multline, etc.)
%\usepackage{bm}      % Bold Math package, defines the command \bf{}
%\usepackage{paralist}% extended list environments
%%subfig.sty is the modern replacement for subfigure.sty. However, subfig.sty
%%requires and automatically loads caption.sty which overrides class handling
%%of captions. To prevent this problem, preload caption.sty with caption=false
%\usepackage[caption=false]{caption}
%\usepackage[font=footnotesize]{subfig}


%user defined variables
\def\papertitle{Zero-cost abstractions to manage audio resource allocation in functional audio languages}
\def\firstauthor{Mike Solomon}

% adds the automatic
% Saves a lot of output space in PDF... after conversion with the distiller
% Delete if you cannot get PS fonts working on your system.

% pdf-tex settings: detect automatically if run by latex or pdflatex
\newif\ifpdf
\ifx\pdfoutput\relax
\else
   \ifcase\pdfoutput
      \pdffalse
   \else
      \pdftrue
\fi

\ifpdf % compiling with pdflatex
  \usepackage[pdftex,
    pdftitle={\papertitle},
    pdfauthor={\firstauthor},
    bookmarksnumbered, % use section numbers with bookmarks
    pdfstartview=XYZ % start with zoom=100% instead of full screen;
                     % especially useful if working with a big screen :-)
   ]{hyperref}
  %\pdfcompresslevel=9

  \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are and their extensions so
  %you won't have to specify these with every instance of \includegraphics
  \graphicspath{{./figures/}}
  \DeclareGraphicsExtensions{.pdf,.jpeg,.png}

  \usepackage[figure,table]{hypcap}

\else % compiling with latex
  \usepackage[dvips,
    bookmarksnumbered, % use section numbers with bookmarks
    pdfstartview=XYZ % start with zoom=100% instead of full screen
  ]{hyperref}  % hyperrefs are active in the pdf file after conversion

  \usepackage[dvips]{epsfig,graphicx}
  % declare the path(s) where your graphic files are and their extensions so
  %you won't have to specify these with every instance of \includegraphics
  \graphicspath{{./figures/}}
  \DeclareGraphicsExtensions{.eps}

  \usepackage[figure,table]{hypcap}
\fi

%setup the hyperref package - make the links black without a surrounding frame
\hypersetup{
    colorlinks,%
    citecolor=black,%
    filecolor=black,%
    linkcolor=black,%
    urlcolor=black
}


% Title.
% ------
\title{\papertitle}

% Authors
% Please note that submissions are NOT anonymous, therefore
% authors' names have to be VISIBLE in your manuscript.
%
% Single address
% To use with only one author or several with the same address
% ---------------
\oneauthor
   {\firstauthor} {wags.fm \\ %
     {\tt \href{mailto:mike@wavr.so}{mike@wavr.so}}}



% ***************************************** the document starts here ***************
\begin{document}
%
\capstartfalse
\maketitle
\capstarttrue
%
\begin{abstract}
Audio programming languages fall into two broad categories: imperative (CSound, sclang) and functional (Faust, tidal). For the latter, the declarative and immutable nature of data and control structures are often at odds with the mutable and referentially opaque nature of audio units like oscillators and filters. Recently, languages such as Rust have bridged this chasm through zero-cost abstractions that manage resource allocation in otherwise functional settings. In the same spirit, this paper presents a zero-cost abstraction for the management of audio units when working with pure audio rendering functions. The result is automatic audio memory management that incurs minimal runtime penalty while retaining an expressive functional syntax.
\end{abstract}
%

\section{Introduction}\label{sec:introduction}
The prevailing resource-management paradigm in all modern DAWs and most visual or text-based music creation environments is to model resources as units that are connected to each other. This is done via patcher chords in PD and Max, busses in SuperCollider, and argument passing in CSound.

%\begin{figure}[t]
%\centering
%\includegraphics[width=0.6\columnwidth]{figure}
%\caption{Figure captions should be placed below the figure,exactly like this.\label{fig:audio-units}}
%\end{figure}

% web audio example
% max example
% supercollider example

Almost all audio units preserve some notion of state internally. For example:

\begin{itemize}
\item Waveforms remember their previous position in a lookup table so that changes in frequency do not disrupt phase.
\item Biquad filters and delay lines need to access a certain number of input samples in the past as well as potentially their own output.
\item FFT-based algorithms need to access and aggregate previous FFTs using a windowing function before rendering the output in the time domain.
\end{itemize}

Because of this, subbing out one audio-unit for another cannot be done in the same way that one would substitute a referrentially transparent value like a floating-point number or boolean. In the most extreme cases, for example with a convolution unit, there are undesirable audio artifacts coupled with seconds of lost rendering data.

In imperative audio programming langauges, such as the Web Audio API or PureData, managing stateful units is a core feature of the language. Variables reference a specific generator that on which arbitrary side effects, like setting a frequency or a volume, can be performed:

\lstset{language=Java, style=psstyle}
\begin{lstlisting}
const oscillator = ctx.createOscillator();
oscillator.type = "square";
oscillator
  .frequency
  .setValueAtTime(440, ctx.currentTime);
oscillator.connect(ctx.destination);
oscillator.start();
\end{lstlisting}

However, in graph-based langauges, this is more challenging. Consider, for example, the following pseudocode:

\lstset{language=Haskell, style=psstyle}
\begin{lstlisting}
type KPT = { time :: Number, kp :: Boolean }
render :: KPT -> AudioGraph
render { time, kp } =
  (
    if time < 5
    then sinOsc (time * 220)
    else if time < 10
    then sinOsc (time * 50)
    else highpass (playBuf "hi")
  ) <>
  (
    when kp (sinOsc 880)
  )
\end{lstlisting}

We are now demanding much more of the audio engine:
\begin{itemize}
\item Even though we haven't specified it, in almost all circumstances we will want to preserve the sine-wave oscillator across the five-second mark to avoid phase disruption.
\item We do not want the engine to spuriously tear down or create new oscillators, for example arbitrarily changing oscialltor units before the 10-second mark.
\item We want as little runtime accounting as possible, ideally precompiling an efficient kernel to minimize how much time is spent on our control thread.
\end{itemize}

As graph-based languages such as Tidal Cycles and PureScript Wags become more prevelant, it is important to maintain the helpful abstraction of graphs as a pure function of time while rigorously keeping track of active and inactive audio units with as little computational overhead as possible.

This paper proposes a zero-cost abstraction to manage resource allocation in functional audio programming languages combining the following three techniques:

\begin{enumerate}
  \item Cofree comonads~\cite{kmettfree, freeman2017declarative}, as popualrized by Edward Kmett.
  \item Existential quantification~\cite{perry1991implementation, laufer1994polymorphic}, first introduced as a programming paradigm by Nigel Perry.
  \item Indexed types~\cite{zenger1997indexed}, which can be used to control transitions between states at compile time using a type checker like that of Rust, Scala, Haskell or PureScript.
\end{enumerate}

The paper will give examples of all three concepts, showing how they can be combined into an audio-resource management strategy and finally showing a real-world stress test using PureScript Wags.

\section{Cofree comonads}
\label{sec:cofree_comonads}

To understand what cofree comonads are, it is helpful to first define the following concepts in order: the functor, the comonad, and finally the cofree comonad.

\subsection{Functor}

A functor is a computational context into which functions can be mapped. For example, if there is a function $add1$ that adds one to integers, it can be mapped to the context of an array of integers $[1,2,3,4]$ to produce $[2,3,4,5]$ or to the context of a homogeneous record $\{x:1,y:2\}$ to produce $\{x:2,y:3\}$. The standard definition of $map$ is
$\forall\,a\, b. (a \rightarrow b) \rightarrow m\,a \rightarrow m\,b$, mapping a function $(a \rightarrow b)$ to operate in context $m$.

Functors are ubiquitous in audio programming: for example, when we apply a function $transposeSemitone$ to a sequence of notes, we understand intuitively that the transposition function is lifted into the context of the sequence even though a rhythmic sequence, pedantically speaking, cannot be ``transposed''.

While functors provide a way to lift functions into contexts, they provide no way to extract values from those contexts, nor do they provide a way to recursively nest contexts. As we'll see in the next section, these are bread-and-butter operations in any realtime audio rendering engine, and this is where comonads come in.

\subsection{Comonad}

A comonad\footnote{Comonads are not to be confused with their close cousins, monads. While monads are outside the scope of this article, they are the categorical dual of comonads and can be used to model a large class of computations.} $w$ is a functor that comes equipped with two operations that fulfill two laws.

The operations are as follows:

\begin{itemize}
  \item $extract$, which extracts a value $a$ from the context $w$.
  \item $duplicate$, which takes a context $w\,a$ and ``nests'' or ``projects'' it into $w(w\,a)$.
\end{itemize}

These operations must satisfy the following laws, where $e$ is $extract$, $d$ is $duplicate$, and $wa$ is an arbitrary comonad:

\begin{itemize}
  \item $e\,(d (wa)) = wa$
  \item $map\,e\,(d (wa)) = wa$
\end{itemize}

The $map$ in the second law is the $map$ discussed above for functors.

In realtime audio programming, $extract$ is the operation to get information like control-rate data or samples from a computational context. $duplicate$ is the operation that takes a context and computes its logical next iteration, which is almost always a rendering or event loop. For example, in the SuperCollider code base, this is defined in \texttt{SC\_EventLoop.hpp}.

Event loops have an additional unique property that is not captured by comonads - for any one iteration, they are \textit{functorial} in nature. That is, the loop is almost never simply executed: it often exists in a computational context that furnishes it with information like the current time and external interactions via transports like MIDI or OSC. So, if the resultant control-rate data or sample buffer is $s$ and the loop's context is a functor $f$, then we have $w (f\,s)$, which is no longer a comonad of $s$ but one of $f\,s$. To resolve this dilemma, we introduce the \textit{cofree comonad}.

\subsection{Cofree comonad}

\textit{Cofree} is a data structure that is parameterized by two types: a functor $f$ and a value $a$. The definition is:

\lstset{language=Haskell, style=psstyle}
\begin{lstlisting}
data Cofree f a =
  Cofree a (f (Cofree f a))
\end{lstlisting}

In languages with strict evaluation, this recursive definition would cause a stack overflow, and in practice, the definition often uses a:

\lstset{language=Haskell, style=psstyle}
\begin{lstlisting}
data Cofree f a =
  Cofree a (Unit -> f (Cofree f a))
\end{lstlisting}

The $Cofree$ constructor takes two arguments: a value $a$ and a computational context $f$ in which one can reason about the next $Cofree\,f\,a$. Note that the next $Cofree\,f\,a$ need not actually exist\footnote{For example, a functor $f$ can choose to ignore its argument $a$, as is the case with ie the $Proxy$ functor, \url{https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-Proxy.html}.}) - event loops can enter into failure states for example, but most server-based programs (ie \texttt{scsynth}) are built around the concept of a potentially infinite event loop.

Cofree is a functor because it has the following instance for $map$:

\lstset{language=Haskell, style=psstyle}
\begin{lstlisting}
map f (Cofree a b) =
  Cofree (f a) (map (map f) b)
\end{lstlisting}

It is a comonad because it has the following instances for $extract$ and $duplicate$:

\lstset{language=Haskell, style=psstyle}
\begin{lstlisting}
extract (Cofree a _) = a
duplicate c@(Cofree _ b) =
  Cofree c (map duplicate b)
\end{lstlisting}

Most importantly, $Cofree$ can be unwrapped by returning the second argument:

\lstset{language=Haskell, style=psstyle}
\begin{lstlisting}
unwrapCofree :: Cofree f a -> f (Cofree f a)
unwrapCofree (Cofree _ b) = b
\end{lstlisting}

In an audio rendering engine, for example, this gives us the next iteration of a rendering loop $f\,a$. For example, if $f$ is $Function\,\{ time :: Number \}$, then at each unwrapping of the loop, we ``unlock'' the next step by providing the current time. This is also called the generator pattern in imperative languages like Python.

\subsection{Revisiting our pseudocode}

Let's revisit our pseudocode through the prism of cofree comonads. We'll reduce the size of the example for brevity:

\lstset{language=Haskell, style=psstyle}
\begin{lstlisting}
type KPT = { time :: Number, kp :: Boolean }
render :: KPT -> AudioGraph
render { time, kp } =
  (
    if time < 5
    then sinOsc (time * 220)
    else highpass (playBuf "hi")
  ) <> (when kp (sinOsc 880))
\end{lstlisting}

We can rewrite this as a function that yields a cofree comonad which yields an audio graph and an event loop.

\lstset{language=Haskell, style=psstyle}
\begin{lstlisting}
type KPT = { time :: Number, kp :: Boolean }
render :: KPT -> Cofree ((->) KPT) AudioGraph
render { time, kp } =
  Cofree
    (
      (
        if time < 5
        then sinOsc (time * 220)
        else highpass (playBuf "hi")
      ) <> (when kp (sinOsc 880))
    )
    render
\end{lstlisting}

Here, beacuse the underlying Functor is \texttt{((->) KPT)}=, we can use \texttt{render} recursively in its own definition. So, \texttt{extract} yields our control-rate data whereas \texttt{unwrap\-Cofree} yields the next iteration of the event loop.

In practice, this also changes the way the event loop is written. When using pure functions, an event loop can be written like so (assuming that one is in an asynchronous effectful monadic context like \texttt{IO} in Haskell or \texttt{Aff} in PureScript).

\lstset{language=Haskell, style=psstyle}
\begin{lstlisting}
-- with pure functions
loop = do
  time <- getTime
  kp <- ketKp
  let res = render { time, kp }
  doSomethingWith res
  delay 0.03
  loop

-- with a cofree comonad
loop =
  let f r = do
    time <- getTime
    kp <- ketKp
    let res = render { time, kp }
    doSomethingWith (extract res)
    delay 0.03
    f (unwrapCofree res)
  in f render
\end{lstlisting}

So far, this formulation provides no advantage over a pure function of time. However, things get more interesting when we introduce arbitrary internal states in the definition of our cofree comonad. For example, if we want the sine-wave oscillator to release one second after a keypress ends, there is no way to do this with a pure function of time because there is no retention of state. Cofree comonads, on the other hand, make this trivial.

\lstset{language=Haskell, style=psstyle}
\begin{lstlisting}
type KPT = { time :: Number, kp :: Boolean }
render :: KPT -> Cofree ((->) KPT) AudioGraph
render  =
  let
    f kp_1 t_1 { time, kp } =
      Cofree
        (
          (
            if time < 5
            then sinOsc (time * 220)
            else highpass (playBuf "hi")
          ) <>
          (when (kp || time < t_1 + 1)
                (sinOsc 880))
        )
        (
          render kp
            (if kp_1 && not kp
                then time else t_1)
        )
  in f false (-inf)
\end{lstlisting}

While this section has showed us how to write an event loop and how to extract krate/arate data from a computation in a functional style, it still has not solved the issue of resource management of stateful audio units. To do this, we will need to introduce the concept of existential quantification and use that to build a indexed type system within a cofree comonad.

\section{Existential quantification}
\label{sec:existential_quantification}

In the last example from Section \ref{sec:cofree_comonads}, we saw how state can be curried in a cofree comonad's definition to create effects like delayed releases of oscilators and in general any sort of memory cell needed for filtering and delay lines.

This technique of passing an term internally through a computation is called a \textit{closure}. The terms \texttt{t\_1} and \texttt{kp\_1} were \textit{lexically closed} within the environment of the cofree comonad, but were never exposed to the external computation.  This technique comes with one major drawback, however: all functions that operate on the external state need to be defined within the closure, which makes it difficult to operate on the state using external APIs.

To remedy this problem, we can use existential types. We say the type is existentially quanitified, or a coend~\cite{yoneda1960ext}, when a consumer of the type knows only that it exists without knowing what the type is. As an example, the \texttt{Exists} type in PureScript can be used to turn any type constructor $f\,a$ into an existential type $\exists a. f\,a$.

\lstset{language=Haskell, style=psstyle}
\begin{lstlisting}
data StreamF a s = StreamF s (s -> Tuple s a)
type Stream a = Exists (StreamF a)
\end{lstlisting}

One can then get into and out of the existential type using the following two functions:

\lstset{language=Haskell, style=psstyle}
\begin{lstlisting}
mkExists :: forall a f. f a -> Exists f
runExists
  :: forall r f
  . (forall a. f a -> r)
  -> Exists f
  -> r
\end{lstlisting}

A useful way to think about existential types is in terms of epistemic certainty. If a universally quantified definition is true ``for all'' types (this is the norm in functional programming languages, for example the $identity$ function is defined as $\forall a. a \rightarrow a$), then it is a tautology. On the other hand, existential types are the weakest epistomological claim one can make: they assert that something exists without knowing anything about it.

We can use existential types to transform the closure from our previous render loop into an API that exposes the internal state to external consumers. This new type is called \texttt{WithCtrl}, and existential types are used to transform it into a cofree comonad that the rendering loop understands.

\lstset{language=Haskell, style=psstyle}
\begin{lstlisting}
type WithCtrl f a c = Cofree f (a /\ c)
type Ex f a = Exists (WithCtrl f a)
type KPT = { time :: Number, kp :: Boolean }
render
  :: KPT
  -> WithCtrl ((->) KPT) AudioGraph KPT
render  =
  let
    f n t =
      Cofree
        (
          ((
            if n.time < 5
            then sinOsc (n.time * 220)
            else highpass (playBuf "hi")
          ) <>
          (when (n.kp || n.time < t.time + 1)
                (sinOsc 880))) /\ t
        )
        (
          render n.kp
            (if t.kp && not n.kp
                then n.time else t.time)
        )
  in f false (-inf)

asEx :: KPT -> E ((->) KPT) AudioGraph
asEx = mkExists <<< render

unEx
  :: E ((->) KPT) AudioGraph
  -> Cofree ((->) KPT) AudioGraph
unEx = runExists (map fst)
\end{lstlisting}

Where closures and existential types shine in recursively defined data structures like cofree comonads is their ability to change over the lifetime of a loop at compile time. This significantly improves runtime performance (no pattern matching) and makes it easier to reason about programs, as non-sensical data (ie a filter's \texttt{q} value being passed to a sine wave oscillator) is prohibited at the type level. It is also a necessary stepping stone to indexed types, which is the crux of our resource-management strategy in Section \ref{sec:existential_quantification}.

As a motivating example, let's use a render function that switches from an oscillator and a filtered sound at the five-second mark. The behavior of the oscillator and of the filtered sound change irreversibly once a key is pressed. As a first pass, we'll use closures to implement this behavior.

\lstset{language=Haskell, style=psstyle}
\begin{lstlisting}
renderHP kp_1 fq { kp } =
  let
    isKp = kp_1 || kp
    f = fq.f + (isKp ? 0 : 1000)
    q = fq.q + (isKp ? 0 : 40)
  in Cofree
    (highpass {f: f, q: q } (playBuf "hi"))
    ( render isKp fq)

renderS kp_1 f { time, kp } =
  if time > 5
  then renderHP kp_1 {f:900,q:1} {time,kp}
  else
    let
        isKp = kp_1 || kp
        f = f.f + (isKp ? 0 : 200)
      in Cofree
        (sinOsc {f: f})
        (renderS isKp fq)

render = renderS false {f: 440}
\end{lstlisting}

The types of the two internal states, \texttt{fq} and \texttt{f}, are different: one (used in \texttt{renderS}) contains frequency information for an oscillator whereas the other (used in \texttt{renderHP}) contains frequency and q values for a filter. And yet, they can be used inside the closure with no runtime penalty (ie no pattern matching on a union) and no danger of accidentally passing information for the filter to the oscillator or vice versa.

It's possible to pass from closures to existential types by using the continuation passing pattern~\cite{sussman14ai}, whereby the control flow of a function (in our case, the loop) is yielded to a continuation. We'll use a slightly different formulation, dispensing with the \texttt{Exists} type for brevity while retaining the same technique of hiding an internal type parameter \texttt{c} using an existential type.\footnote{Note that, in this example, lazy evaluation is assumed. In strict languages, it causes a stack overflow and the construction of the cofree comonad would need to be deferred.}

\lstset{language=Haskell, style=psstyle}
\begin{lstlisting}
flip f a b = f b a
type Intern f a c = Cofree f (a /\ c)
type Extern f a = Cofree f a

cp a b = map (map fst) (b a)

renderHP kp_1 fq { kp } =
  let
    isKp = kp_1 || kp
    f = fq.f + (isKp ? 0 : 1000)
    q = fq.q + (isKp ? 0 : 40)
  in Cofree
    (highpass {f: f, q: q } (playBuf "hi"))
    ( render isKp fq) /\ fq

renderS kp_1 f { kp } =
  let
    isKp = kp_1 || kp
    f = f.f + (isKp ? 0 : 200)
  in Cofree
    (sinOsc {f: f})
    (renderS isKp fq) /\ f

render =
  let z i a =
    if i.time > 5
    then f a z
    else
      cp
        (renderHP kp_1 {f:900,q:1} {time,kp})
        (flip cp)
  let f x = cp x z
  in f (renderS false {f: 440})
\end{lstlisting}

Now, it is possible to define functions that interact directly with the data types yielded by \texttt{renderHP} and \texttt{renderS}, both of which expose their internal state. Furthermore, we have abstracted time management outside of the definition of \texttt{renderS} to the toplevel \texttt{render} function, allowing the delegation of temporal branching to different control structures. The function \texttt{cp} takes care of the type erasure from \texttt{Intern} to \texttt{Extern} in the same way that \texttt{Exists} erases a type.

Recasting type-level changes of internal states from closures to existential types does more than allow us to write APIs for interacting with an internal state. It also the crucial step that allows us to reason about resource management, as we will see in the next section on indexed types.

\section{Indexed types}
\label{sec:indexed_types}

If we take a closer look at the interaction between \texttt{Intern f a c} and \texttt{Extern f a}, we see that it erases a single type --- the internal state \texttt{c} of the cofree comonad. This erasure also happens at the term level --- we drop \texttt{c} from the final cofree comonad. If we didn't drop this term, we would lose the ability to vary \texttt{c} as a function of time, as we saw in examples from Section \ref{sec:existential_quantification}.

Nothing stops us from erasing multiple types, however, nor do all of the types have to appear in the corresponding terms. For example, we could have defined intern as {type Intern f i o a c = Cofree f (a /\ c)}. Here, \texttt{i} and \texttt{o} are phantom types: in addition to being erased, they have no representation at the term level in the cofree comonad. Instead, we can use types like these to track aspects of our program at compile time. This is called a ``zero-cost abstraction'': it is an abstraction that offloads complexity entirely to the compiler and is erased at the term level, or otherwise stated, there is no runtime penalty.

When phantom types are used in this way, we call them \textit{indexed types}. The term index is used similarly as in set theory, where a collection (in this case a collection of control-rate values for an audio graph) is indexed by a set (in this case, the audio graph).

Indexed types are the key to managing the allocation of resources of an audio graph using cofree comonads. Changes in indices represent changes in the underlying audio graph. For example, if index $i_0$ is \texttt{SinOsc} and index $i_1$ is \texttt {Highpass (PlayBuf)}, the compiler knows that it will ahve to destroy a sine wave oscillator and create a playable buffer linked to a highpass filter.

Because types $i_0,i_1,...,i_n,...$ are potentially different at each iteration of the rendering loop, they cannot appear in the type of the final cofree comonad \texttt{Cofree f a}. Instead, they must be erased via existential quantification using the same techniques we used in the previous section.

Let's see this technique applied to the same example above where a sine-wave oscillator changes to a filtered buffer. For brevity, we will not include the function definitions - just the function signatures that are used. For several examples of function definitions that accomplish this, one may consult the example folder of the \texttt{purescript-wags} project\footnote{\url{https://github.com/mikesol/purescript-wags/tree/main/examples/kitchen-sink}}.

\lstset{language=Haskell, style=psstyle}
\begin{lstlisting}
type KPT = { time :: Number, kp :: Boolean }
flip f a b = f b a
type Intern f a i c = ...
type Extern f a = ...
type F = { f :: Number }
type Fq = { f :: Number, q :: Number }
type IKPT = Intern ((->) KPT)
trans0
  :: IKPT AudioGraph F EmptyGraph
  -> IKPT AudioGraph F SinOsc
trans1
  :: IKPT AudioGraph F SinOsc
  -> IKPT AudioGraph F SinOsc
trans2
  :: IKPT AudioGraph F SinOsc
  -> IKPT AudioGraph Fq (HighPass (PlayBuf))
trans3
  :: IKPT AudioGraph Fq (HighPass (PlayBuf))
  -> IKPT AudioGraph Fq (HighPass (PlayBuf))
\end{lstlisting}

This example is more complex in that there are four transitions between indexed states:
\begin{enumerate}
  \item At time 0, a transition from the empty graph to a sine-wave oscillator.
  \item At all remaining times until five seconds, a noop.
  \item At the five-second mark, transition from a sine-wave oscillator to a filtered buffer.
  \item From here until the audio is shut off, a noop.
\end{enumerate}

These transitions are tracked entirely at compile-time, which speeds up audio rendering substantially in that there is no need to track changes in the potentially-very-large audio graph at runtime. Instead, the only changes that need to be propagated to the graph are new control values, which requires no diff between graphs.

Before looking at benchmarks in the next section, let's revisit the path to indexed types to show how the allocation of audio resources can be tracked by indices in a purely functional setting.

\begin{enumerate}
  \item Instead of repeatedly calling a pure function of time, rendering loops can unfold a cofree comonad that yields functions of time at each iteration.
  \item Cofree comonads can have changing internal states, and these internal states can be represented at the typelevel as complex types that are transformed into simpler cofree comonads via existential quantification.
  \item One of these existentially-eliminated types can be an index that tracks the current state of the audio graph. The compiler, as it tracks the evolution of this type, can emit efficient instructions for graph manipulations at compile-time, eliminating the need for runtime graph traversals.
\end{enumerate}

\section{Example and benchmark}
\label{sec:example_and_benchmark}

To illustrate the runtime benefits of this approach, the following test was run.

\begin{enumerate}
  \item An audio graph with 61 units - 1 speaker, 30 gain controls and 30 sine-wave oscillators, was created twice in web audio using Google Chrome. Both versions model an audio graph as a pure function of time.\footnote{The function can be seen at the following URL: \url{https://github.com/mikesol/purescript\-wags/blob/b6930c5aab6ec5f04f7d8d07231a04b12f70388e/examples/smc2022/SMC2022.purs\#L39}.}
  \begin{enumerate}[label*=\arabic*.]
    \item The first version\footnote{See this url: \url{https://github.com/mikesol/purescript\-wags/blob/b6930c5aab6ec5f04f7d8d07231a04b12f70388e/examples/smc2022/SMC2022.purs\#L74}.} uses the zero-cost abstraction described in this paper.
    \item The second version uses a runtime graph traversal to detect changes in the graph.
  \end{enumerate}
  \item Approximately ten seconds of audio was rendered using the both versions.
  \item The results are as follows:
  \begin{enumerate}[label*=\arabic*.]
    \item The first version's audio rendering took approximately 1.7\% of the total rendering time. This is shown in Figure \ref{fig:first_version_rendering}.
    \item The first version's audio rendering took 38.8\% of the total rendering time. This is shown in Figure \ref{fig:second_version_rendering}.
  \end{enumerate}
\end{enumerate}


\begin{figure}[t]
\centering
\includegraphics[width=0.6\columnwidth]{fast}
\caption{The rendering result of an audio graph created using zero-cost abstractions at compile-time.\label{fig:first_version_rendering}}
\end{figure}

\begin{figure}[t]
\centering
\includegraphics[width=0.6\columnwidth]{slow}
\caption{The rendering result of an audio graph created using runtime graph traversals.\label{fig:second_version_rendering}}
\end{figure}

This shows that, for a moderately complex audio graph, the zero-cost abstraction was over 22 times faster than the version that made runtime graph traversals. This result can be reproduced at the following url: \url{https://smc2022.surge.sh}.

\section{Conclusion}

As functionalal audio programming becomes more ubiquitous and as large media houses like Epic Games\footnote{See \url{https://discourse.haskell.org/t/an-epic-future-for-spj/3573}} turn to functional programming to power parts of their rendering pipelines, the need for efficient representations of purely functional audio graphs becomes increasingly important. This paper presents a zero-cost abstraction for managing audio graph resources by using existential typing to erase indexed representations of audio graphs in a cofree comonad. The resulting algorithm was able to outperform a runtime graph traversal by a factor of 22 on a moderately complex graph. While the algorithm was presented in Haskell-family pseudocode, the technique can be applied to any language that can perform typelevel functions on partially-applied types, as \texttt{Exists} does in this paper. This includes Scala, F\#, PureScript, Agda and Idris. By following this method, artists can benefit from the conceptual elegance and power of the functional style while enjoying the fast runtime traditionally associated with imperative languages.

\label{sec:conclusion}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%bibliography here
\bibliography{smc2022bib}

\end{document}
